diff --git a/src/scalar_mul/digits.rs b/src/scalar_mul/digits.rs
index 9e8f352..b348aa9 100644
--- a/src/scalar_mul/digits.rs
+++ b/src/scalar_mul/digits.rs
@@ -79,36 +79,49 @@ use scalar::Scalar;
 ///
 /// Ideally we avoid actually doing a carry, and just keep the carry bit.
 fn new_naf(x: &Scalar, w: usize) -> [i8;256] {
-    let mut naf = [0;256];
+    let mut naf = [0i8;256];
 
-    let width = 1 << w;
-    let window_mask = width - 1;
+    let width = 1 << w;  // 2^w
+    let window_mask = width - 1;  // w bits
     
     let mut pos = 0;
     let mut carry = 0;
+    let words: [u64;5] = [
+        LittleEndian::read_u64(&x.bytes[0..]),
+        LittleEndian::read_u64(&x.bytes[8..]),
+        LittleEndian::read_u64(&x.bytes[16..]),
+        LittleEndian::read_u64(&x.bytes[24..]),
+        0 // extra word to avoid extra bounds check in the loop
+    ];
     while pos < 256 {
         let u64_pos = pos / 64; // which u64 chunk to read
         let u64_idx = pos % 64; // which bit within that chunk
-        let bit_buf = LittleEndian::read_u64(&x.bytes[8*u64_pos..]);
-        let window = carry + ((bit_buf >> u64_idx) & window_mask);
+        let bit_buf = words[u64_pos];
+        let mut val = (bit_buf >> u64_idx) & window_mask;
+        // if we have some bits in the next word, and there is a next word, 
+        // then we should add them to the value
+        if u64_idx > (64 - w) {
+            let extra_bits = w - (64 - u64_idx); // number of bits are in the next word
+            let bit_buf_next = words[u64_pos + 1];
+            val += (bit_buf_next & ((1<<extra_bits)-1)) << (w - extra_bits);
+        }
+        let window = carry + val;
 
         if window & 1 == 0 {
-            naf[pos] = 0;
+            //println!("[c={:?}][{:?} {:?}:{:?}] -> {:?} is even, emitting zero", carry, pos, u64_pos, u64_idx, window);
             pos += 1;
             continue;
         }
 
         if window < width/2 {
+            //println!("[c={:?}][{:?} {:?}:{:?}] -> {:?} < width/2, setting carry to 0, advancing by w={:?}", carry, pos, u64_pos, u64_idx, window, w);
             carry = 0;
             naf[pos] = window as i8;
         } else {
+            //println!("[c={:?}][{:?} {:?}:{:?}] -> {:?} >= width/2, setting carry to 1, subtracting width={:?}, advancing by w={:?}", carry, pos, u64_pos, u64_idx, window, width, w);
             carry = 1;
             naf[pos] = (window as i8) - (width as i8);
         }
-
-        for i in 1..w {
-            naf[pos+i] = 0;
-        }
         pos += w;
     }
 
@@ -119,16 +132,26 @@ fn new_naf(x: &Scalar, w: usize) -> [i8;256] {
 mod test {
     use super::*;
 
-    #[test]
-    fn compare_newnaf() {
-        let x = Scalar::from_u64(9820398).invert();
-
+    fn naf_compare_helper(x: Scalar) {
         let oldnaf = x.non_adjacent_form().to_vec();
         let newnaf = new_naf(&x, 5).to_vec();
-
         assert_eq!(oldnaf, newnaf);
     }
 
+    #[test]
+    fn compare_newnaf_dense() {
+        let sc = Scalar::from_u64(9820398).invert();
+        //println!("{:?}", sc.bits().to_vec());
+        naf_compare_helper(sc);
+    }
+
+    #[test]
+    fn compare_newnaf_random() {
+        for i in 1..1000 {
+            naf_compare_helper(Scalar::from_u64(i).invert());
+        }
+    }
+
     use test::Bencher;
     use test::black_box;
 
